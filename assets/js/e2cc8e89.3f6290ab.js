"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[574],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(7294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=u(n),p=l,f=m["".concat(s,".").concat(p)]||m[p]||c[p]||i;return n?a.createElement(f,o(o({ref:t},d),{},{components:n})):a.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,o=new Array(i);o[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[m]="string"==typeof e?e:l,o[1]=r;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1474:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var a=n(7462),l=(n(7294),n(3905));const i={title:"Custom Validations"},o=void 0,r={unversionedId:"Guide/customValidation",id:"Guide/customValidation",title:"Custom Validations",description:"Implementing Custom Validation Rules",source:"@site/docs/Guide/customValidation.md",sourceDirName:"Guide",slug:"/Guide/customValidation",permalink:"/docs/Guide/customValidation",draft:!1,editUrl:"https://github.com/naingaungluu/form-conductor/tree/documentation/docs/docs/Guide/customValidation.md",tags:[],version:"current",frontMatter:{title:"Custom Validations"},sidebar:"tutorialSidebar",previous:{title:"Rules",permalink:"/docs/Guide/rules"}},s={},u=[{value:"Implementing Custom Validation Rules",id:"implementing-custom-validation-rules",level:3},{value:"Two types of validation rules",id:"two-types-of-validation-rules",level:3},{value:"Example",id:"example",level:2},{value:"Stateless validation rule",id:"stateless-validation-rule",level:3},{value:"State-based validation rule",id:"state-based-validation-rule",level:3}],d={toc:u};function m(e){let{components:t,...n}=e;return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h3",{id:"implementing-custom-validation-rules"},"Implementing Custom Validation Rules"),(0,l.kt)("p",null,"If you're feeling adventuruous or need to create your own validation rule to be used with the library, you can always create one. You can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"@FieldValiation")," annotation to create custom annotations."),(0,l.kt)("admonition",{type:"caution"},(0,l.kt)("p",{parentName:"admonition"},"You must implement the validation rules as a kotlin ",(0,l.kt)("inlineCode",{parentName:"p"},"object"),".")),(0,l.kt)("h3",{id:"two-types-of-validation-rules"},"Two types of validation rules"),(0,l.kt)("p",null,"Based on your field's nature, you can implement two of the available rules "),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"StatelessValidationRule")," - used for the fields that are independently validated without referencing other fields."),(0,l.kt)("li",{parentName:"ol"},(0,l.kt)("inlineCode",{parentName:"li"},"StateBasedVaildationRule")," - used for the fields that depend on other fields for validation.")),(0,l.kt)("mermaid",{value:"classDiagram    \n    class ValidationRule { <<interface>> }\n\n    class StatelessValidationRule~FieldType,Annotation~ {\n        +validate(value, options)\n    }\n\n    class StateBasedValidationRule~FieldType,Annotation,FormType~ {\n        +validate(value, options, formState)\n    }\n\n    ValidationRule <|-- StatelessValidationRule\n    ValidationRule <|-- StateBasedValidationRule"}),(0,l.kt)("h2",{id:"example"},"Example"),(0,l.kt)("h3",{id:"stateless-validation-rule"},"Stateless validation rule"),(0,l.kt)("p",null,"Let's say we're creating a custom validaton rule for Burmese Mobile numbers. We could implement our own validation logic as follows"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="MobileNumber.kt"',title:'"MobileNumber.kt"'},"@Target(AnnotationTarget.PROPERTY)\n@Retention(AnnotationRetention.RUNTIME)\n@MustBeDocumented\n@FieldValidation(\n    fieldType = String::class,\n    validator = MobileNumberRule::class\n)\nannotation class MobileNumber(\n    val country: Country\n)\n\nenum Country {\n    Myanmar,\n    Other\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="MobileNumberRule.kt"',title:'"MobileNumberRule.kt"'},'object MobileNumberRule : StatelessValidationRule<String, MobileNumber> {\n\n    override fun validate(value: String, options: MobileNumber): FieldResult {\n        \n        return when (options.country) {\n            Country.Myanmar -> {\n                if (value.startsWith("+95")) {\n                    FieldResult.Success\n                } else {\n                    FieldResult.Error("Burmese mobile number must start with +95", this)\n                }\n            }\n            else -> FieldResult.Success\n        }\n\n    }\n\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="SignUpFormData.kt"',title:'"SignUpFormData.kt"'},"@Form\ndata class SignUpFormData(\n    \n    ...\n\n    @MobileNumber(Country.Myanmar)\n    val mobilelNo: String\n)\n")),(0,l.kt)("h3",{id:"state-based-validation-rule"},"State-based validation rule"),(0,l.kt)("p",null,"Let's say we'd like to create a validator for date of birth which depends on the type of user select in another field named ",(0,l.kt)("inlineCode",{parentName:"p"},"userType"),". Validation logic is like if ",(0,l.kt)("inlineCode",{parentName:"p"},"userType")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"Adult"),", date of birth must be at least 13 years and above."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="UserType.kt"',title:'"UserType.kt"'},"enum class UserType {\n    Adult,\n    Child\n}\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="CustomDateOfBirth.kt"',title:'"CustomDateOfBirth.kt"'},"@Target(AnnotationTarget.PROPERTY)\n@Retention(AnnotationRetention.RUNTIME)\n@MustBeDocumented\n@FieldValidation(\n    fieldType = LocalDate::class,\n    validator = CustomDateOfBirthRule::class\n)\nannotation class CustomDateOfBirth()\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="CustomDateOfBirthRule.kt"',title:'"CustomDateOfBirthRule.kt"'},'object CustomDateOfBirthRule: StateBasedValidationRule<LocalDate, CustomDateOfBirth, SignUpFormData> {\n    \n    override fun validate(value: LocalDate, options: CustomDateOfBirth, formState: SignUpFormData): FieldResult {\n        // Note: We\'re referencing the current value of `formState.userType` for validation\n        return when (formState.userType) {\n            UserType.Adult -> validateAdult(value)\n            UserType.Child -> validateChild(value)\n        }\n    }\n\n    private fun validateAdult(date: LocalDate): FieldResult {\n        val minDate = LocalDate.now().minusYears(13)\n        return if (date.isBefore(minDate)) {\n            FieldResult.Success\n        } else {\n            FieldResult.Error("Adult must be older than 13.", this)\n        }\n    }\n\n    private fun valildateChild(date: LocalDate): FieldResult {\n        val maxDate = LocalDate.now().minusYears(13)\n        return if (date.isAfter(maxDate)) {\n            FieldResult.Success\n        } else {\n            FieldResult.Error("Child must be youngr than 13.", this)\n        }\n    }\n}\n')),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-kotlin",metastring:'title="SignUpFormData.kt"',title:'"SignUpFormData.kt"'},"@Form\ndata class SignUpFormData(\n    \n    ...\n\n    val userType: UserType\n\n    @CustomDateOfBirth\n    val dateOfBirth: LocalDate\n\n    ...\n)\n")))}m.isMDXComponent=!0}}]);